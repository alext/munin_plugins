#!/usr/bin/env ruby

if $0 =~ /^(?:|.*\/)http_([^_]+)_/
  host = $1
end
abort "# Error: couldn't understand what I'm supposed to monitor." unless host

password = ENV['password'] || 'user'

require 'net/http'
require 'rexml/document'

class SuperhubStats

  def initialize(host, password)
    @host = host
    @password = password
  end

  def acquisition_status
    table = get_table('Modem Initialisation')
    get_row_value(table, 'Downstream Acquisition')
  end

  def counters
    table = get_table('Modem Initialisation')
    get_row_value(table, 'Counters').split(',').map(&:strip).map(&:to_i)
  end

  def downstream_channel_details
    table = get_table('Downstream Channels')
    table.get_elements(".//tbody//tr").map do |row|
      {
        :lock_status => row.get_elements(".//td[1]").first.text,
        :rx_power => row.get_elements(".//td[5]").first.text,
        :snr => row.get_elements(".//td[6]").first.text,
        :post_rs_errors => row.get_elements(".//td[8]").first.text.to_i,
      }
    end
  end

  def upstream_channel_details
    table = get_table('Upstream Channels')
    table.get_elements(".//tbody//tr").map do |row|
      {
        :lock_status => row.get_elements(".//td[1]").first.text,
        :tx_power => row.get_elements(".//td[5]").first.text,
      }
    end
  end

  def downstream_channel_status
    table = get_table('Downstream Channels')
    table.get_elements(".//tbody//td[1]").map(&:text)
  end

  def post_rs_errors
    table = get_table('Downstream Channels')
    table.get_elements(".//tbody//td[8]").map(&:text).map(&:to_i)
  end

  def stats_page
    @stats_page ||= REXML::Document.new(load_stats_page)
  end

  private

  def get_table(caption)
    stats_page.get_elements("//table[.//caption[contains(., '#{caption}')]]").first
  end

  def get_row_value(table, row_title)
    table.get_elements(".//tr[.//td[@class='title'][contains(., '#{row_title}')]]//td[2]").first.text
  end

  def load_stats_page
    @page = get_stats_page
    unless @page =~ /Network Status/
      login
    end
    @page
  end

  def login
    uri = URI.parse("http://#{@host}#{login_path}")
    resp = Net::HTTP.post_form(uri, "VmLoginPassword" => @password)
    unless resp['Location'] =~ %r{/home.asp}
      raise "Login failed"
    end
    @page = get_stats_page
    unless @page =~ /Network Status/
      raise "Login process failed"
    end
  end

  def login_path(do_retry = true)
    if @page =~ %r{<form\s+id="signIn"\s+action=(\S+)}
      return $1
    elsif do_retry
      @page = Net::HTTP.get(@host, '/VmLogin.asp')
      login_path(false)
    else
      puts @page
      raise "Couldn't find login form"
    end
  end

  def get_stats_page
    Net::HTTP.get(@host, '/VmRgNetworkStatus.asp')
  end
end

if (ARGV[0] == 'config')
  puts "host_name #{host}" unless host == 'localhost'

  puts <<-EOT
multigraph counters
graph_title Counters
graph_category network
graph_args -l 0
t1.label T1
t1.type DERIVE
t1.min 0
t1.draw LINE1
t2.label T2
t2.type DERIVE
t2.min 0
t2.draw LINE1
t3.label T3
t3.type DERIVE
t3.min 0
t3.draw LINE1
t4.label T4
t4.type DERIVE
t4.min 0
t4.draw LINE1
sync.label Sync
sync.type DERIVE
sync.min 0
sync.draw LINE1
resets.label Resets
resets.type DERIVE
resets.min 0
resets.draw LINE1
post_rs_errors.label Post RS Errors
post_rs_errors.type DERIVE
post_rs_errors.min 0
post_rs_errors.draw LINE1
  EOT

  puts <<-EOT
multigraph locked_channels
graph_title Locked channels
graph_category network
graph_args -l 0
downstream.label Downstream
downstream.draw LINE1
upstream.label Upstream
upstream.draw LINE1
  EOT
  # puts config details
  #
  # Graph: Counters
  # Graph: Connected channels (up and down)
  # Graph: Downstream Post RS errors
  # Graph: Downstream power levels
  # Graph: upstream power levels

  exit 0
end

stats = SuperhubStats.new(host, password)

puts "multigraph counters"
counters = stats.counters
puts "t1.value #{counters[0]}"
puts "t2.value #{counters[1]}"
puts "t3.value #{counters[2]}"
puts "t4.value #{counters[3]}"
puts "sync.value #{counters[4]}"
puts "resets.value #{counters[5]}"

downstream_details = stats.downstream_channel_details
upstream_details = stats.upstream_channel_details
post_rs_errors = downstream_details.inject(0) {|total, ch| total += ch[:post_rs_errors] }
puts "post_rs_errors.value #{post_rs_errors}"

puts "multigraph locked_channels"
puts "downstream.value #{downstream_details.select {|ch| ch[:lock_status] == "Locked"}.size}"
puts "upstream.value #{upstream_details.select {|ch| ch[:lock_status] == "Locked"}.size}"

#puts "Status: #{stats.acquisition_status}"
#puts stats.downstream_channel_status.inspect
#puts stats.post_rs_errors.inspect

# puts graph data
